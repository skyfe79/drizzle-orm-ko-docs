---
title: "Prismaì—ì„œ Drizzleë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•˜ê¸°"
---

import Steps from "@mdx/Steps.astro";
import Npm from "@mdx/Npm.astro";

## ì‹œì‘í•˜ê¸°


ì´ ê°€ì´ë“œëŠ” ê¸°ë³¸ì ì¸ **Prisma** í”„ë¡œì íŠ¸ë¥¼ **Drizzle ORM**ìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•˜ëŠ” ê°„ë‹¨í•œ ë°©ë²•ì„ ì œê³µí•©ë‹ˆë‹¤. ì˜ˆì œëŠ” `PostgreSQL`ì„ ì¤‘ì‹¬ìœ¼ë¡œ ì„¤ëª…í•˜ì§€ë§Œ, ë‹¤ë¥¸ ì§€ì› ë°ì´í„°ë² ì´ìŠ¤ì—ì„œë„ ë¹„ìŠ·í•œ ê³¼ì •ì„ ê±°ì¹©ë‹ˆë‹¤.


### ë§ˆì´ê·¸ë ˆì´ì…˜ í”„ë¡œì„¸ìŠ¤ ê°œìš”

ì—¬ëŸ¬ë¶„ì˜ ì• í”Œë¦¬ì¼€ì´ì…˜ íƒ€ì…ì´ë‚˜ API ë ˆì´ì–´ì— ìƒê´€ì—†ì´, **Prisma**ì—ì„œ **Drizzle ORM**ìœ¼ë¡œ ì „í™˜í•˜ëŠ” ê³¼ì •ì€ ë™ì¼í•©ë‹ˆë‹¤:

1. **Drizzle ORM**ê³¼ **Drizzle Kit** ì„¤ì¹˜
2. **Drizzle config** íŒŒì¼ ì„¤ì •
3. ë°ì´í„°ë² ì´ìŠ¤ êµ¬ì¡° ë¶„ì„
4. **Drizzle ORM**ì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì—°ê²°
5. **Prisma** ì¿¼ë¦¬ë¥¼ **Drizzle ORM** ì¿¼ë¦¬ë¡œ ì „í™˜

ì´ ë‹¨ê³„ë“¤ì€ REST API(ì˜ˆ: Express, Koa, NestJS)ë¥¼ ê°œë°œí•˜ê±°ë‚˜, **Prisma**ë¥¼ ì‚¬ìš©í•´ ë°ì´í„°ë² ì´ìŠ¤ì™€ ìƒí˜¸ì‘ìš©í•˜ëŠ” ë‹¤ë¥¸ íƒ€ì…ì˜ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ê°œë°œí•  ë•Œ ëª¨ë‘ ì ìš©ë©ë‹ˆë‹¤.


## Prisma í”„ë¡œì íŠ¸ ê°œìš”

ì´ ê°€ì´ë“œì—ì„œëŠ” **Drizzle ORM**ìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜í•  ì˜ˆì œ í”„ë¡œì íŠ¸ë¡œ `Express`ë¡œ êµ¬ì¶•ëœ REST APIë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ í”„ë¡œì íŠ¸ì—ëŠ” ë„¤ ê°€ì§€ ì—”í‹°í‹°ê°€ ìˆìŠµë‹ˆë‹¤:

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Product {
  id              Int           @id @default(autoincrement())
  name            String
  supplierId      Int
  unitPrice       Decimal       @db.Decimal(10, 4)
  unitsInStock    Int

  supplier        Supplier?     @relation(fields: [supplierId], references: [id])
  orderDetails    OrderDetail[]

  @@map("products")
}

model Supplier {
  id           Int       @id @default(autoincrement())
  companyName  String
  city         String
  country      String

  products     Product[]

  @@map("suppliers")
}

model OrderDetail {
  orderId   Int
  productId Int
  quantity  Int

  order   Order   @relation(fields: [orderId], references: [id])
  product Product @relation(fields: [productId], references: [id])

  @@id([orderId, productId])
  @@map("order_details")
}

model Order {
  id             Int       @id @default(autoincrement())
  orderDate      DateTime  @db.Date
  shippedDate    DateTime? @db.Date
  shipAddress    String
  shipPostalCode String?
  shipCountry    String

  orderDetails OrderDetail[]

  @@map("orders")
}
```

ì´ ëª¨ë¸ë“¤ì€ ë‹¤ìŒê³¼ ê°™ì€ ê´€ê³„ë¥¼ ê°€ì§€ê³  ìˆìŠµë‹ˆë‹¤:

1. `Supplier`ì™€ `Product` ì‚¬ì´ì˜ `ì¼ëŒ€ë‹¤` ê´€ê³„
2. `Order`ì™€ `Product` ì‚¬ì´ì˜ `ë‹¤ëŒ€ë‹¤` ê´€ê³„

`ë‹¤ëŒ€ë‹¤` ê´€ê³„ë¥¼ ìœ„í•´ ì¡°ì¸ í…Œì´ë¸”ì¸ `order_details`ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. ë”°ë¼ì„œ `Order`ì™€ `Product` ì—”í‹°í‹°ëŠ” `OrderDetail` ì—”í‹°í‹°ì™€ `ì¼ëŒ€ë‹¤` ê´€ê³„ë¥¼ ê°–ê²Œ ë©ë‹ˆë‹¤.

í•´ë‹¹ í…Œì´ë¸”ë“¤ì€ Prisma ë§ˆì´ê·¸ë ˆì´ì…˜ì„ í†µí•´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.

```sql
-- CreateTable
CREATE TABLE "products" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "supplierId" INTEGER NOT NULL,
    "unitPrice" DECIMAL(10,4) NOT NULL,
    "unitsInStock" INTEGER NOT NULL,

    CONSTRAINT "products_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "suppliers" (
    "id" SERIAL NOT NULL,
    "companyName" TEXT NOT NULL,
    "city" TEXT NOT NULL,
    "country" TEXT NOT NULL,

    CONSTRAINT "suppliers_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "order_details" (
    "orderId" INTEGER NOT NULL,
    "productId" INTEGER NOT NULL,
    "quantity" INTEGER NOT NULL,

    CONSTRAINT "order_details_pkey" PRIMARY KEY ("orderId","productId")
);

-- CreateTable
CREATE TABLE "orders" (
    "id" SERIAL NOT NULL,
    "orderDate" DATE NOT NULL,
    "shippedDate" DATE,
    "shipAddress" TEXT NOT NULL,
    "shipPostalCode" TEXT,
    "shipCountry" TEXT NOT NULL,

    CONSTRAINT "orders_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "products" ADD CONSTRAINT "products_supplierId_fkey" FOREIGN KEY ("supplierId") REFERENCES "suppliers"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_details" ADD CONSTRAINT "order_details_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "order_details" ADD CONSTRAINT "order_details_productId_fkey" FOREIGN KEY ("productId") REFERENCES "products"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
```

ì´ ê°€ì´ë“œì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ íŒŒì¼ êµ¬ì¡°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:

```plaintext
ğŸ“¦ <project root>
 â”œ ğŸ“‚ prisma
 â”‚  â”œ ğŸ“‚ migrations
 â”‚  â”‚  â”œ ğŸ“‚ 20240101200233_init
 â”‚  â”‚  â”‚  â”” ğŸ“œ migration.sql
 â”‚  â”‚  â”” ğŸ“œ migration_lock.toml
 â”‚  â”” ğŸ“œ schema.prisma
 â”œ ğŸ“‚ src
 â”‚  â”œ ğŸ“‚ db
 â”‚  â”‚  â”” ğŸ“œ db.ts
 â”‚  â”œ ğŸ“‚ routers
 â”‚  â”‚  â”œ ğŸ“œ order.router.ts
 â”‚  â”‚  â”œ ğŸ“œ product.router.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.router.ts
 â”‚  â”œ ğŸ“‚ controllers
 â”‚  â”‚  â”œ ğŸ“œ order.controller.ts
 â”‚  â”‚  â”œ ğŸ“œ product.controller.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.controller.ts
 â”‚  â”œ ğŸ“œ index.ts
 â”‚  â”” ğŸ“œ server.ts
 â”œ ğŸ“œ package.json
 â”” ğŸ“œ tsconfig.json
```

<Steps>


#### Drizzle ORMê³¼ Drizzle Kit ì„¤ì¹˜í•˜ê¸°

ë¨¼ì € **Drizzle ORM**ê³¼ ë“œë¼ì´ë²„ë¡œ ì‚¬ìš©í•  `pg` íŒ¨í‚¤ì§€ë¥¼ ì„¤ì¹˜í•©ë‹ˆë‹¤. ê·¸ë‹¤ìŒìœ¼ë¡œ **Drizzle Kit**ê³¼ `pg`ì˜ íƒ€ì… ì •ì˜ë¥¼ ì„¤ì¹˜í•©ë‹ˆë‹¤. [Drizzle Kit](/docs/kit-overview)ì€ ìë™ SQL ë§ˆì´ê·¸ë ˆì´ì…˜ ìƒì„±ê³¼ ë¹ ë¥¸ í”„ë¡œí† íƒ€ì´í•‘ì„ ìœ„í•œ CLI ë„êµ¬ì…ë‹ˆë‹¤.

<Npm>
drizzle-orm pg
-D drizzle-kit @types/pg
</Npm>


#### Drizzle ì„¤ì • íŒŒì¼ êµ¬ì„±í•˜ê¸°

**Drizzle ì„¤ì • íŒŒì¼**ì€ **Drizzle Kit**ì—ì„œ ì‚¬ìš©í•˜ëŠ” íŒŒì¼ë¡œ, ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì •ë³´, ë§ˆì´ê·¸ë ˆì´ì…˜ í´ë”, ìŠ¤í‚¤ë§ˆ íŒŒì¼ ë“± ëª¨ë“  ì •ë³´ë¥¼ ë‹´ê³  ìˆìŠµë‹ˆë‹¤.

í”„ë¡œì íŠ¸ ë£¨íŠ¸ì— `drizzle.config.ts` íŒŒì¼ì„ ìƒì„±í•˜ê³  ë‹¤ìŒ ë‚´ìš©ì„ ì¶”ê°€í•˜ì„¸ìš”:

```typescript copy filename="drizzle.config.ts"
import 'dotenv/config'; // dotenv íŒ¨í‚¤ì§€ ì„¤ì¹˜ í•„ìš”
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'postgresql', // ë°ì´í„°ë² ì´ìŠ¤ ì¢…ë¥˜
  out: './src/drizzle', // ì¶œë ¥ ë””ë ‰í† ë¦¬
  schema: './src/drizzle/schema.ts', // ìŠ¤í‚¤ë§ˆ íŒŒì¼ ê²½ë¡œ
  dbCredentials: {
    host: process.env.DB_HOST!, // ë°ì´í„°ë² ì´ìŠ¤ í˜¸ìŠ¤íŠ¸
    port: Number(process.env.DB_PORT!), // ë°ì´í„°ë² ì´ìŠ¤ í¬íŠ¸
    user: process.env.DB_USERNAME!, // ì‚¬ìš©ì ì´ë¦„
    password: process.env.DB_PASSWORD!, // ë¹„ë°€ë²ˆí˜¸
    database: process.env.DB_NAME!, // ë°ì´í„°ë² ì´ìŠ¤ ì´ë¦„
  },
  verbose: true, // ëª¨ë“  ëª…ë ¹ë¬¸ ì¶œë ¥
  strict: true, // í•­ìƒ í™•ì¸ ìš”ì²­
});
```

ì´ ì„¤ì • íŒŒì¼ì€ Drizzle Kitì´ ë°ì´í„°ë² ì´ìŠ¤ì™€ ìƒí˜¸ì‘ìš©í•˜ëŠ” ë° í•„ìš”í•œ ì •ë³´ë¥¼ ì œê³µí•©ë‹ˆë‹¤. `dotenv` íŒ¨í‚¤ì§€ë¥¼ ì‚¬ìš©í•´ í™˜ê²½ ë³€ìˆ˜ë¥¼ ë¡œë“œí•˜ê³ , ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì •ë³´ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. `verbose`ì™€ `strict` ì˜µì…˜ì„ í†µí•´ ëª…ë ¹ë¬¸ ì¶œë ¥ê³¼ í™•ì¸ ìš”ì²­ì„ í™œì„±í™”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


#### ë°ì´í„°ë² ì´ìŠ¤ ë‚´ë¶€ êµ¬ì¡° í™•ì¸í•˜ê¸°

**Drizzle Kit**ì€ ë°ì´í„°ë² ì´ìŠ¤ì˜ ë‚´ë¶€ êµ¬ì¡°ë¥¼ í™•ì¸í•˜ê³  ìŠ¤í‚¤ë§ˆ íŒŒì¼ì„ ìƒì„±í•˜ëŠ” CLI ì»¤ë§¨ë“œë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì´ ìŠ¤í‚¤ë§ˆ íŒŒì¼ì€ ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸”, ì»¬ëŸ¼, ê´€ê³„, ì¸ë±ìŠ¤ì— ëŒ€í•œ ëª¨ë“  ì •ë³´ë¥¼ í¬í•¨í•©ë‹ˆë‹¤.

```bash
npx drizzle-kit introspect
```

ì´ ì»¤ë§¨ë“œë¥¼ ì‹¤í–‰í•˜ë©´ `src/drizzle` í´ë”ì— `schema.ts` íŒŒì¼ê³¼ ìŠ¤ëƒ…ìƒ·, ë§ˆì´ê·¸ë ˆì´ì…˜ íŒŒì¼ì´ ìƒì„±ë©ë‹ˆë‹¤.

```typescript collapsable copy filename="src/drizzle/schema.ts"
import {
  pgTable,
  varchar,
  timestamp,
  text,
  integer,
  serial,
  foreignKey,
  numeric,
  date,
  primaryKey,
} from 'drizzle-orm/pg-core';
import { sql } from 'drizzle-orm';

export const prismaMigrations = pgTable('_prisma_migrations', {
  id: varchar('id', { length: 36 }).primaryKey().notNull(),
  checksum: varchar('checksum', { length: 64 }).notNull(),
  finishedAt: timestamp('finished_at', { withTimezone: true, mode: 'string' }),
  migrationName: varchar('migration_name', { length: 255 }).notNull(),
  logs: text('logs'),
  rolledBackAt: timestamp('rolled_back_at', { withTimezone: true, mode: 'string' }),
  startedAt: timestamp('started_at', { withTimezone: true, mode: 'string' }).defaultNow().notNull(),
  appliedStepsCount: integer('applied_steps_count').default(0).notNull(),
});

export const suppliers = pgTable('suppliers', {
  id: serial('id').primaryKey().notNull(),
  companyName: text('companyName').notNull(),
  city: text('city').notNull(),
  country: text('country').notNull(),
});

export const products = pgTable('products', {
  id: serial('id').primaryKey().notNull(),
  name: text('name').notNull(),
  supplierId: integer('supplierId')
    .notNull()
    .references(() => suppliers.id, { onDelete: 'restrict', onUpdate: 'cascade' }),
  unitPrice: numeric('unitPrice', { precision: 10, scale: 4 }).notNull(),
  unitsInStock: integer('unitsInStock').notNull(),
});

export const orders = pgTable('orders', {
  id: serial('id').primaryKey().notNull(),
  orderDate: date('orderDate').notNull(),
  shippedDate: date('shippedDate'),
  shipAddress: text('shipAddress').notNull(),
  shipPostalCode: text('shipPostalCode'),
  shipCountry: text('shipCountry').notNull(),
});

export const orderDetails = pgTable(
  'order_details',
  {
    orderId: integer('orderId')
      .notNull()
      .references(() => orders.id, { onDelete: 'restrict', onUpdate: 'cascade' }),
    productId: integer('productId')
      .notNull()
      .references(() => products.id, { onDelete: 'restrict', onUpdate: 'cascade' }),
    quantity: integer('quantity').notNull(),
  },
  (table) => {
    return {
      orderDetailsPkey: primaryKey({ columns: [table.orderId, table.productId], name: 'order_details_pkey' }),
    };
  },
);
```

```sql collapsable copy filename="src/drizzle/0000_cool_puff_adder.sql"
CREATE TABLE IF NOT EXISTS "_prisma_migrations" (
	"id" varchar(36) PRIMARY KEY NOT NULL,
	"checksum" varchar(64) NOT NULL,
	"finished_at" timestamp with time zone,
	"migration_name" varchar(255) NOT NULL,
	"logs" text,
	"rolled_back_at" timestamp with time zone,
	"started_at" timestamp with time zone DEFAULT now() NOT NULL,
	"applied_steps_count" integer DEFAULT 0 NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "suppliers" (
	"id" serial PRIMARY KEY NOT NULL,
	"companyName" text NOT NULL,
	"city" text NOT NULL,
	"country" text NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "products" (
	"id" serial PRIMARY KEY NOT NULL,
	"name" text NOT NULL,
	"supplierId" integer NOT NULL,
	"unitPrice" numeric(10, 4) NOT NULL,
	"unitsInStock" integer NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "orders" (
	"id" serial PRIMARY KEY NOT NULL,
	"orderDate" date NOT NULL,
	"shippedDate" date,
	"shipAddress" text NOT NULL,
	"shipPostalCode" text,
	"shipCountry" text NOT NULL
);
--> statement-breakpoint
CREATE TABLE IF NOT EXISTS "order_details" (
	"orderId" integer NOT NULL,
	"productId" integer NOT NULL,
	"quantity" integer NOT NULL,
	CONSTRAINT order_details_pkey PRIMARY KEY("orderId","productId")
);
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "products" ADD CONSTRAINT "products_supplierId_fkey" FOREIGN KEY ("supplierId") REFERENCES "suppliers"("id") ON DELETE restrict ON UPDATE cascade;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "order_details" ADD CONSTRAINT "order_details_orderId_fkey" FOREIGN KEY ("orderId") REFERENCES "orders"("id") ON DELETE restrict ON UPDATE cascade;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
--> statement-breakpoint
DO $$ BEGIN
 ALTER TABLE "order_details" ADD CONSTRAINT "order_details_productId_fkey" FOREIGN KEY ("productId") REFERENCES "products"("id") ON DELETE restrict ON UPDATE cascade;
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;
```

ê´€ê³„í˜• ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ìŠ¤í‚¤ë§ˆ íŒŒì¼ì— ê´€ê³„í˜• í…Œì´ë¸”ì„ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤:

```typescript copy filename="src/drizzle/schema.ts"
// ...ë‹¤ë¥¸ import
import { relations } from 'drizzle-orm';

// ...ë‹¤ë¥¸ í…Œì´ë¸”
export const suppliersRelations = relations(suppliers, ({ many }) => ({
  products: many(products),
}));

export const productsRelations = relations(products, ({ one, many }) => ({
  supplier: one(suppliers, { fields: [products.supplierId], references: [suppliers.id] }),
  orderDetails: many(orderDetails),
}));

export const ordersRelations = relations(orders, ({ many }) => ({
  orderDetails: many(orderDetails),
}));

export const orderDetailsRelations = relations(orderDetails, ({ one }) => ({
  order: one(orders, { fields: [orderDetails.orderId], references: [orders.id] }),
  product: one(products, { fields: [orderDetails.productId], references: [products.id] }),
}));
```

ì´ì œ ë‹¤ìŒê³¼ ê°™ì€ íŒŒì¼ êµ¬ì¡°ê°€ ìƒì„±ë©ë‹ˆë‹¤:

```plaintext
ğŸ“¦ <project root>
 â”œ ğŸ“‚ src
 â”‚  â”œ ğŸ“‚ drizzle
 â”‚  â”‚  â”œ ğŸ“‚ meta
 |  |  |  â”œ ğŸ“œ _journal.json
 â”‚  â”‚  â”‚  â”” ğŸ“œ 0000_snapshot.json
 â”‚  â”‚  â”œ ğŸ“œ 0000_cool_puff_adder.sql
 â”‚  â”‚  â”” ğŸ“œ schema.ts
 â”‚  â”œ ğŸ“‚ routers
 â”‚  â”‚  â”œ ğŸ“œ order.router.ts
 â”‚  â”‚  â”œ ğŸ“œ product.router.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.router.ts
 â”‚  â”œ ğŸ“‚ controllers
 â”‚  â”‚  â”œ ğŸ“œ order.controller.ts
 â”‚  â”‚  â”œ ğŸ“œ product.controller.ts
 â”‚  â”‚  â”” ğŸ“œ supplier.controller.ts
 â”‚  â”œ ğŸ“œ index.ts
 â”‚  â”” ğŸ“œ server.ts
 â”œ ğŸ“œ package.json
 â”œ ğŸ“œ drizzle.config.ts
 â”” ğŸ“œ tsconfig.json
```


#### Drizzle ORMì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì—°ê²°í•˜ê¸°

`src/drizzle` í´ë” ì•ˆì— `db.ts` íŒŒì¼ì„ ìƒì„±í•˜ê³  ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •ì„ êµ¬ì„±í•©ë‹ˆë‹¤:

```typescript
import { drizzle } from 'drizzle-orm/node-postgres';
import { Client } from 'pg';
import * as schema from './schema';

export const client = new Client({
  host: process.env.DB_HOST!,
  port: Number(process.env.DB_PORT!),
  user: process.env.DB_USERNAME!,
  password: process.env.DB_PASSWORD!,
  database: process.env.DB_NAME!,
});

// { schema }ëŠ” ê´€ê³„í˜• ì¿¼ë¦¬ë¥¼ ìœ„í•´ ì‚¬ìš©ë©ë‹ˆë‹¤
export const db = drizzle({ client, schema });
```

```typescript
import 'dotenv/config';
import { client, db } from './drizzle/db';
import { resolve } from 'node:path';
import { migrate } from 'drizzle-orm/node-postgres/migrator';

(async () => {
  await client.connect();

  // ì´ ì»¤ë§¨ë“œëŠ” migrations í´ë”ì˜ ëª¨ë“  ë§ˆì´ê·¸ë ˆì´ì…˜ì„ ì‹¤í–‰í•˜ê³  ë°ì´í„°ë² ì´ìŠ¤ì— ë³€ê²½ ì‚¬í•­ì„ ì ìš©í•©ë‹ˆë‹¤
  await migrate(db, { migrationsFolder: resolve(__dirname, './drizzle') });

  // ... ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘
})();
```


#### Prisma ì¿¼ë¦¬ë¥¼ Drizzle ORM ì¿¼ë¦¬ë¡œ ì „í™˜í•˜ê¸°

ì´ë²ˆ ì„¹ì…˜ì—ì„œëŠ” **Prisma**ì—ì„œ ì‚¬ìš©í•˜ë˜ ì—¬ëŸ¬ ì¿¼ë¦¬ë¥¼ **Drizzle ORM**ìœ¼ë¡œ ëŒ€ì²´í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•©ë‹ˆë‹¤.


### ë°ì´í„° ì‚½ì… ì¿¼ë¦¬ ë³€ê²½í•˜ê¸°

`suppliers`ì™€ `products` í…Œì´ë¸”ì— ìƒˆë¡œìš´ í–‰ì„ ì‚½ì…í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.

#### 1. `POST /suppliers`

**Prisma**ë¥¼ ì‚¬ìš©í•œ ì¿¼ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

```typescript
import { prisma } from '../db/db';

await prisma.supplier.createMany({
  data: [
    { companyName: 'TestCompanyName1', city: 'TestCity1', country: 'TestCountry1' },
    { companyName: 'TestCompanyName2', city: 'TestCity2', country: 'TestCountry2' },
  ],
});
```

**Drizzle ORM**ì„ ì‚¬ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```typescript
import { db } from '../drizzle/db';
import { suppliers } from '../drizzle/schema';

await db.insert(suppliers).values([
  {
    companyName: 'TestCompanyName1',
    city: 'TestCity1',
    country: 'TestCountry1',
  },
  {
    companyName: 'TestCompanyName2',
    city: 'TestCity2',
    country: 'TestCountry2',
  },
]);
```

#### 2. `POST /products`

**Prisma**ë¥¼ ì‚¬ìš©í•œ ì¿¼ë¦¬ëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

```typescript
import { prisma } from '../db/db';

await prisma.product.createMany({
  data: [
    { 
      name: 'TestProductName1',
      supplierId: 1,
      unitPrice: 10,
      unitsInStock: 20,
    },
    {
      name: 'TestProductName2',
      supplierId: 1,
      unitPrice: 25,
      unitsInStock: 7,
    },
    {
      name: 'TestProductName3',
      supplierId: 2,
      unitPrice: 50,
      unitsInStock: 17,
    },
    {
      name: 'TestProductName4',
      supplierId: 2,
      unitPrice: 100,
      unitsInStock: 2,
    },
  ],
});
```

**Drizzle ORM**ì„ ì‚¬ìš©í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

`unitPrice` í•„ë“œì— ì£¼ì˜í•´ì•¼ í•©ë‹ˆë‹¤. **Prisma**ì—ì„œëŠ” `number` íƒ€ì…ì´ì§€ë§Œ, **Drizzle ORM**ì—ì„œëŠ” `string` íƒ€ì…ìœ¼ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤. ì´ëŠ” ì†Œìˆ˜ì  ì´í•˜ 16383ìë¦¬ ì´ìƒì˜ ìˆ«ìë¥¼ ì²˜ë¦¬í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

```typescript
await db.insert(products).values([
  {
    name: 'TestProductName1',
    supplierId: 1,
    unitPrice: '10',
    unitsInStock: 20,
  },
  {
    name: 'TestProductName2',
    supplierId: 1,
    unitPrice: '25',
    unitsInStock: 7,
  },
  {
    name: 'TestProductName3',
    supplierId: 2,
    unitPrice: '50',
    unitsInStock: 17,
  },
  {
    name: 'TestProductName4',
    supplierId: 2,
    unitPrice: '100',
    unitsInStock: 2,
  },
]);
```


##### ì¿¼ë¦¬ ì„ íƒí•˜ê¸°

ì´ë²ˆ ì„¹ì…˜ì—ì„œëŠ” ë‹¨ì¼ í–‰ ì„ íƒ, ì—¬ëŸ¬ í–‰ ì„ íƒ, í–‰ ê°œìˆ˜ ì„¸ê¸°, í–‰ í•„í„°ë§, í…Œì´ë¸” ì¡°ì¸, ê²°ê³¼ í˜ì´ì§• ë°©ë²•ì„ ì‚´í´ë³´ê² ìŠµë‹ˆë‹¤.

1. `GET /products/:id`

```typescript copy filename="src/controllers/product.controller.ts"
import { prisma } from '../db/db';

const { id } = req.params;

const response = await prisma.product.findUnique({
  where: { id },
  include: {
    supplier: true,
  },
});
```

**Drizzle ORM**ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„ë©ë‹ˆë‹¤:

```typescript copy filename="src/controllers/product.controller.ts"
import { eq } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { products, suppliers } from '../drizzle/schema';

const { id } = req.params;

const response = await db
  .select({
    product: products,
    supplier: suppliers,
  })
  .from(products)
  .where(eq(products.id, id))
  .leftJoin(suppliers, eq(suppliers.id, products.supplierId));

// ë˜ëŠ” ê´€ê³„í˜• ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
const response = await db.query.products.findFirst({
  where: (products, { eq }) => eq(products.id, id),
  with: {
    supplier: true,
  },
});
```

ë‘ ORM ëª¨ë‘ íƒ€ì… ì•ˆì „í•œ ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.

```typescript
// Drizzle ORMì˜ ì‘ë‹µ íƒ€ì…
const response: {
  product: {
    name: string;
    id: number;
    supplierId: number;
    unitPrice: string;
    unitsInStock: number;
  };
  supplier: {
    id: number;
    companyName: string;
    city: string | null;
    country: string;
  } | null;
}[]
```

2. `GET /products`

```typescript copy filename="src/controllers/product.controller.ts"
import { Prisma } from '@prisma/client';
import { prisma } from '../db/db';

const whereOptions: Prisma.ProductWhereInput = {
  name: { contains: 'test', mode: 'insensitive' },
};

const [response, count] = await Promise.all([
  prisma.product.findMany({
    where: whereOptions,
    take: 10,
    skip: 0,
    select: {
      id: true,
      name: true,
      unitPrice: true,
      unitsInStock: true,
    },
  }),
  prisma.product.count({ where: whereOptions }),
]);
```

**Drizzle ORM**ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„ë©ë‹ˆë‹¤:

```typescript collapsable copy filename="src/controllers/product.controller.ts"
import { ilike, sql } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { products } from '../drizzle/schema';

const whereOptions = ilike(products.name, `%test%`);

const [response, count] = await Promise.all([
  db
    .select({
      id: products.id,
      name: products.name,
      unitPrice: products.unitPrice,
      unitsInStock: products.unitsInStock,
    })
    .from(products)
    .where(whereOptions)
    .offset(0)
    .limit(10),
  db
    .select({ count: sql`cast(count(${products.id}) as integer)` })
    .from(products)
    .where(whereOptions),
]);

// ë˜ëŠ” ê´€ê³„í˜• ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤
const whereOptions = ilike(products.name, `%test%`);

const [response, count] = await Promise.all([
  db.query.products.findMany({
    where: whereOptions,
    columns: {
      id: true,
      name: true,
      unitPrice: true,
      unitsInStock: true,
    },
    offset: 0,
    limit: 10,
  }),
  db
    .select({ count: sql`cast(count(${products.id}) as integer)` })
    .from(products)
    .where(whereOptions),
]);
```

ë‘ ORM ëª¨ë‘ íƒ€ì… ì•ˆì „í•œ ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.

```typescript
// Drizzle ORMì˜ ì‘ë‹µ íƒ€ì…
const response: {
  id: number;
  name: string;
  unitPrice: string;
  unitsInStock: number;
}[]
```

3. `GET /orders/:id`

**Prisma**ì—ì„œëŠ” ì§‘ê³„ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ `aggregate` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤. ë³µì¡í•œ ì¿¼ë¦¬ì˜ ê²½ìš° íƒ€ì… ì•ˆì „í•˜ì§€ ì•Šì€ `$queryRaw` ë©”ì„œë“œë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.

`orders` í…Œì´ë¸”ì—ì„œ `id`, `orderDate`, `shipCountry` í•„ë“œë¥¼ ì„ íƒí•˜ê³ , `aggregation functions`ë¥¼ ì‚¬ìš©í•´ ì£¼ë¬¸ì˜ `totalPrice` í•©ê³„, ì£¼ë¬¸ ë‚´ ì œí’ˆì˜ `totalQuantity` í•©ê³„, ì£¼ë¬¸ ë‚´ ì œí’ˆ ê°œìˆ˜ `totalProducts`ë¥¼ ì„¸ì–´ì•¼ í•©ë‹ˆë‹¤.

```typescript copy filename="src/controllers/order.controller.ts"
import { prisma } from '../db/db';

const { id } = req.params;

const order = await prisma.order.findFirst({
  where: { id },
  select: {
    id: true,
    orderDate: true,
    shipCountry: true,
  },
});
if (!order) {
  throw new Error('Order not found');
}

const { _count, _sum } = await prisma.orderDetail.aggregate({
  where: { orderId: id },
  _sum: {
    quantity: true,
  },
  _count: {
    orderId: true,
  },
});

const totalPrice: Array = await prisma.$queryRaw`
  SELECT SUM(unitPrice * quantity) as "totalPrice"
  FROM order_details
  WHERE "orderId" = ${id}
`;

const response = {
  ...order,
  totalPrice: totalPrice[0].totalPrice,
  totalQuantity: _sum.quantity,
  totalProducts: _count.orderId,
};
```

**Drizzle ORM**ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì´ êµ¬í˜„ë©ë‹ˆë‹¤:

```typescript copy filename="src/controllers/order.controller.ts"
import { eq, sql } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { orders, orderDetails, products } from '../drizzle/schema';

const { id } = req.params;

const response = await db
      .select({
        id: orders.id,
        shipCountry: orders.shipCountry,
        orderDate: orders.orderDate,
        totalPrice: sql`cast(sum(${orderDetails.quantity} * ${products.unitPrice}) as float)`,
        totalQuantity: sql`cast(sum(${orderDetails.quantity}) as int)`,
        totalProducts: sql`cast(count(${orderDetails.productId}) as int)`,
      })
      .from(orders)
      .where(eq(orders.id, id))
      .groupBy(orders.id)
      .leftJoin(orderDetails, eq(orderDetails.orderId, orders.id))
      .leftJoin(products, eq(products.id, orderDetails.productId));
```

**Drizzle ORM**ì—ì„œëŠ” ì§‘ê³„ ê²°ê³¼ë„ íƒ€ì… ì•ˆì „í•©ë‹ˆë‹¤.

```typescript
// ì‘ë‹µ íƒ€ì…
const response: {
  id: number;
  shipCountry: string;
  orderDate: string;
  totalPrice: number;
  totalQuantity: number;
  totalProducts: number;
}[]
```

**ì°¸ê³ :** í˜„ì¬ ê´€ê³„í˜• ì¿¼ë¦¬ì—ì„œëŠ” ì§‘ê³„ë¥¼ ì§€ì›í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ `core queries`ë¥¼ ì‚¬ìš©í•´ì•¼ í•©ë‹ˆë‹¤.


##### ì—¬ëŸ¬ í–‰ ì—…ë°ì´íŠ¸í•˜ê¸°

ì´ë²ˆ ì„¹ì…˜ì—ì„œëŠ” ì—¬ëŸ¬ í–‰ì„ ì—…ë°ì´íŠ¸í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.

1. `PATCH /suppliers/:id`

```typescript copy filename="src/controllers/supplier.controller.ts"
import { prisma } from '../db/db';

const { id } = req.params;

const supplier = await prisma.supplier.update({
  where: { id },
  data: { city: 'TestCity1Updated', country: 'TestCountry1Updated' },
});
```

**Drizzle ORM**ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì¿¼ë¦¬ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```typescript copy filename="src/controllers/supplier.controller.ts"
import { eq } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { suppliers } from '../drizzle/schema';

const { id } = req.params;

await db
    .update(suppliers)
    .set({
      city: 'TestCity1Updated',
      country: 'TestCountry1Updated',
    })
    .where(eq(suppliers.id, id));
```


##### ì‚­ì œ ì¿¼ë¦¬ ëŒ€ì²´í•˜ê¸°

ì´ë²ˆ ì„¹ì…˜ì—ì„œëŠ” íŠ¸ëœì­ì…˜ì„ ì‚¬ìš©í•˜ì—¬ ë‹¨ì¼ í–‰ê³¼ ì—¬ëŸ¬ í–‰ì„ ì‚­ì œí•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤.

1. `DELETE /orders/:id`

```typescript copy filename="src/controllers/order.controller.ts"
import { prisma } from '../db/db';

const { id } = req.params;

const orderDetailQuery = prisma.orderDetail.deleteMany({
  where: { orderId: id },
});

const orderQuery = prisma.order.deleteMany({
  where: { id },
});

await prisma.$transaction([orderDetailQuery, orderQuery]);
```

**Drizzle ORM**ì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì´ ì¿¼ë¦¬ë¥¼ êµ¬í˜„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

```typescript copy filename="src/controllers/order.controller.ts"
import { eq } from 'drizzle-orm';
import { db } from '../drizzle/db';
import { orderDetails, orders } from '../drizzle/schema';

const { id } = req.params;

try {
  await db.transaction(async (tx) => {
    await tx.delete(orderDetails).where(eq(orderDetails.orderId, id));

    await tx.delete(orders).where(eq(orders.id, id));
  });
} catch (e) {
  console.error(e);
}
```


</Steps>